// Code generated by protoc-gen-gogo.
// source: default.proto
// DO NOT EDIT!

/*
	Package errors is a generated protocol buffer package.

	It is generated from these files:
		default.proto

	It has these top-level messages:
		DefaultError
*/
package errors

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "gogo/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type DefaultErrorType int32

const (
	DefaultErrorType_OTHER                DefaultErrorType = 0
	DefaultErrorType_NOT_FOUND_BY_KEY     DefaultErrorType = 1000000
	DefaultErrorType_INVALID_MESSAGE_TYPE DefaultErrorType = 1000001
	DefaultErrorType_TIMEOUT              DefaultErrorType = 1000002
	DefaultErrorType_BUSY                 DefaultErrorType = 1000003
	DefaultErrorType_NOT_CONNECTED        DefaultErrorType = 1000004
	DefaultErrorType_FAIL                 DefaultErrorType = 1000005
	DefaultErrorType_ENCODING             DefaultErrorType = 1000006
)

var DefaultErrorType_name = map[int32]string{
	0:       "OTHER",
	1000000: "NOT_FOUND_BY_KEY",
	1000001: "INVALID_MESSAGE_TYPE",
	1000002: "TIMEOUT",
	1000003: "BUSY",
	1000004: "NOT_CONNECTED",
	1000005: "FAIL",
	1000006: "ENCODING",
}
var DefaultErrorType_value = map[string]int32{
	"OTHER":                0,
	"NOT_FOUND_BY_KEY":     1000000,
	"INVALID_MESSAGE_TYPE": 1000001,
	"TIMEOUT":              1000002,
	"BUSY":                 1000003,
	"NOT_CONNECTED":        1000004,
	"FAIL":                 1000005,
	"ENCODING":             1000006,
}

func (x DefaultErrorType) String() string {
	return proto.EnumName(DefaultErrorType_name, int32(x))
}
func (DefaultErrorType) EnumDescriptor() ([]byte, []int) { return fileDescriptorDefault, []int{0} }

type DefaultError struct {
	Code   uint32            `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Idx    int32             `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
	Str    string            `protobuf:"bytes,3,opt,name=str,proto3" json:"str,omitempty"`
	Fields map[string]string `protobuf:"bytes,4,rep,name=fields" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DefaultError) Reset()                    { *m = DefaultError{} }
func (m *DefaultError) String() string            { return proto.CompactTextString(m) }
func (*DefaultError) ProtoMessage()               {}
func (*DefaultError) Descriptor() ([]byte, []int) { return fileDescriptorDefault, []int{0} }

func (m *DefaultError) GetFields() map[string]string {
	if m != nil {
		return m.Fields
	}
	return nil
}

func init() {
	proto.RegisterType((*DefaultError)(nil), "errors.DefaultError")
	proto.RegisterEnum("errors.DefaultErrorType", DefaultErrorType_name, DefaultErrorType_value)
}
func (m *DefaultError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDefault(dAtA, i, uint64(m.Code))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDefault(dAtA, i, uint64(m.Idx))
	}
	if len(m.Str) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDefault(dAtA, i, uint64(len(m.Str)))
		i += copy(dAtA[i:], m.Str)
	}
	if len(m.Fields) > 0 {
		for k, _ := range m.Fields {
			dAtA[i] = 0x22
			i++
			v := m.Fields[k]
			mapSize := 1 + len(k) + sovDefault(uint64(len(k))) + 1 + len(v) + sovDefault(uint64(len(v)))
			i = encodeVarintDefault(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDefault(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintDefault(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func encodeFixed64Default(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Default(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintDefault(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DefaultError) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDefault(uint64(m.Code))
	}
	if m.Idx != 0 {
		n += 1 + sovDefault(uint64(m.Idx))
	}
	l = len(m.Str)
	if l > 0 {
		n += 1 + l + sovDefault(uint64(l))
	}
	if len(m.Fields) > 0 {
		for k, v := range m.Fields {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDefault(uint64(len(k))) + 1 + len(v) + sovDefault(uint64(len(v)))
			n += mapEntrySize + 1 + sovDefault(uint64(mapEntrySize))
		}
	}
	return n
}

func sovDefault(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDefault(x uint64) (n int) {
	return sovDefault(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DefaultError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDefault
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDefault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDefault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDefault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDefault
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDefault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDefault
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDefault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDefault
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthDefault
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Fields == nil {
				m.Fields = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDefault
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDefault
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthDefault
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Fields[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Fields[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDefault(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDefault
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDefault(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDefault
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDefault
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDefault
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDefault
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDefault
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDefault(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDefault = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDefault   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("default.proto", fileDescriptorDefault) }

var fileDescriptorDefault = []byte{
	// 356 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x4c, 0x90, 0x4d, 0x4a, 0xc3, 0x40,
	0x18, 0x86, 0x3b, 0xfd, 0xd3, 0x7c, 0x35, 0x32, 0x8c, 0x45, 0x62, 0x17, 0x21, 0xb8, 0x0a, 0x2e,
	0x22, 0xe8, 0xa6, 0x0a, 0x59, 0xb4, 0xcd, 0xb4, 0x06, 0xdb, 0x44, 0xd2, 0x54, 0xc8, 0x2a, 0x54,
	0x93, 0x96, 0x62, 0x31, 0x25, 0x4d, 0xc5, 0xee, 0x73, 0x00, 0x2f, 0xe0, 0x49, 0xdc, 0xf8, 0x8f,
	0x4b, 0x8f, 0x20, 0xf5, 0x22, 0x32, 0x13, 0x17, 0xdd, 0x0c, 0xcf, 0xbc, 0x3c, 0xf3, 0x7e, 0xc3,
	0x07, 0x62, 0x10, 0x8e, 0x86, 0x8b, 0x69, 0xa2, 0xcd, 0xe2, 0x28, 0x89, 0x48, 0x39, 0x8c, 0xe3,
	0x28, 0x9e, 0xd7, 0xf6, 0xc6, 0xd1, 0x38, 0x3a, 0x64, 0x07, 0xcf, 0x39, 0x65, 0xca, 0xfe, 0x13,
	0x82, 0x2d, 0x23, 0x7b, 0x44, 0x99, 0x4c, 0x08, 0x14, 0xaf, 0xa3, 0x20, 0x94, 0x90, 0x82, 0x54,
	0xd1, 0xe1, 0x4c, 0x30, 0x14, 0x26, 0xc1, 0xbd, 0x94, 0x57, 0x90, 0x5a, 0x72, 0x18, 0xb2, 0x64,
	0x9e, 0xc4, 0x52, 0x41, 0x41, 0xaa, 0xe0, 0x30, 0x24, 0x75, 0x28, 0x8f, 0x26, 0xe1, 0x34, 0x98,
	0x4b, 0x45, 0xa5, 0xa0, 0x56, 0x8e, 0x14, 0x2d, 0x1b, 0xae, 0xad, 0xb7, 0x6b, 0x6d, 0xae, 0xd0,
	0xdb, 0x24, 0x5e, 0x3a, 0xff, 0x7e, 0xed, 0x04, 0x2a, 0x6b, 0x31, 0xab, 0xbe, 0x09, 0x97, 0x7c,
	0xbe, 0xe0, 0x30, 0x24, 0x55, 0x28, 0xdd, 0x0d, 0xa7, 0x8b, 0x90, 0x7f, 0x40, 0x70, 0xb2, 0xcb,
	0x69, 0xbe, 0x8e, 0x0e, 0x1e, 0x11, 0xe0, 0xf5, 0x7e, 0x77, 0x39, 0x0b, 0x89, 0x00, 0x25, 0xdb,
	0x3d, 0xa3, 0x0e, 0xce, 0x91, 0x5d, 0xc0, 0x96, 0xed, 0xfa, 0x6d, 0x7b, 0x60, 0x19, 0x7e, 0xd3,
	0xf3, 0xcf, 0xa9, 0x87, 0x9f, 0x53, 0x9d, 0xd4, 0xa0, 0x6a, 0x5a, 0x97, 0x8d, 0xae, 0x69, 0xf8,
	0x3d, 0xda, 0xef, 0x37, 0x3a, 0xd4, 0x77, 0xbd, 0x0b, 0x8a, 0x5f, 0x52, 0x9d, 0x88, 0xb0, 0xe1,
	0x9a, 0x3d, 0x6a, 0x0f, 0x5c, 0xfc, 0x9a, 0xea, 0x04, 0xa0, 0xd8, 0x1c, 0xf4, 0x3d, 0xfc, 0x96,
	0xea, 0x64, 0x07, 0x44, 0x56, 0xd7, 0xb2, 0x2d, 0x8b, 0xb6, 0x5c, 0x6a, 0xe0, 0xf7, 0x4c, 0x68,
	0x37, 0xcc, 0x2e, 0xfe, 0x48, 0x75, 0xb2, 0x0d, 0x9b, 0xd4, 0x6a, 0xd9, 0x86, 0x69, 0x75, 0xf0,
	0x67, 0xaa, 0x37, 0xf1, 0xd7, 0x4a, 0x46, 0xdf, 0x2b, 0x19, 0xfd, 0xac, 0x64, 0xf4, 0xf0, 0x2b,
	0xe7, 0xae, 0xca, 0x7c, 0xed, 0xc7, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x11, 0x61, 0x34, 0xc1,
	0xaa, 0x01, 0x00, 0x00,
}
